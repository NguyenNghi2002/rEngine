#if true
using Engine.BitmapFonts;
using Raylib_cs;
using BitmapFont = Raylib_cs.Font;
using Keys = Raylib_cs.KeyboardKey;
using Raylib_cs.UI.Extra;
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Text;
using Mathf = Raylib_cs.Raymath;
using Engine;
using Engine.Timer;

namespace Engine.UI
{
    /// <summary>
    /// A single-line text input field.
    ///
    /// The preferred height of a text field is the height of the {@link TextFieldStyle#font} and {@link TextFieldStyle#background}.
    /// The preferred width of a text field is 150, a relatively arbitrary size.
    ///
    /// The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is
    /// pressed. Clipboard functionality is provided via the {@link Clipboard} interface.
    ///
    /// The text field allows you to specify an {@link OnscreenKeyboard} for displaying a softkeyboard and piping all key events
    /// generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.
    /// The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android {@link OnscreenKeyboard}
    /// implementation will bring up the default IME.
    /// </summary>
    public class TextField : Element, IInputListener, IKeyboardListener
    {
        public event Action<TextField, string> OnTextChanged;
        public event Action<TextField> OnEnterPressed = delegate { };
        public event Action<TextField> OnTabPressed = delegate { };

        public override float PreferredWidth => _preferredWidth;

        public override float PreferredHeight
        {
            get
            {
                var prefHeight = textHeight;
                if (style.Background != null)
                    prefHeight = Math.Max(prefHeight + style.Background.BottomHeight + style.Background.TopHeight,
                        style.Background.MinHeight);

                return prefHeight;
            }
        }

        /// <summary>
        /// the maximum distance outside the TextField the mouse can move when pressing it to cause it to be unfocused
        /// </summary>
        public float TextFieldBoundaryThreshold = 100f;

        /// <summary>
        /// if true and setText is called it will be ignored
        /// </summary>
        public bool ShouldIgnoreTextUpdatesWhileFocused = true;

        protected string text;
        protected int cursor, selectionStart;
        protected bool hasSelection;
        protected bool writeEnters;
        List<float> glyphPositions = new List<float>(15);

        float _preferredWidth = 150;
        TextFieldStyle style;
        string messageText;
        protected string displayText = string.Empty;
        ITextFieldFilter filter;
        bool focusTraversal = true, onlyFontChars = true, disabled;
        int textHAlign = AlignInternal.Left;
        float selectionX, selectionWidth;
        StringBuilder _textBuffer = new StringBuilder();

        bool passwordMode;
        StringBuilder passwordBuffer;
        char passwordCharacter = '*';

        protected float fontOffset, textHeight, textOffset;
        float renderOffset;
        int visibleTextStart, visibleTextEnd;
        int maxLength = 0;

        float blinkTime = 0.5f;
        bool cursorOn = true;
        float lastBlink;

        bool programmaticChangeEvents;

        protected bool _isOver, _isPressed, _isFocused;
        ITimer _keyRepeatTimer;
        float _keyRepeatTime = 0.05f;
        float _keyRepeatStartTime = 0.3f;


        public TextField(string text, TextFieldStyle style)
        {
            SetStyle(style);
            SetText(text);
            SetSize(PreferredWidth, PreferredHeight);
        }


#if false
        public TextField(string text, Skin skin, string styleName = null) : this(text,
    skin.Get<TextFieldStyle>(styleName))
        { } 
#endif


        #region IInputListener

        float _clickCountInterval = 0.2f;
        int _clickCount;
        float _lastClickTime;

        float _lastClickPressedTime;
        int _clickPressedCount;
        float _clickPressedCountInterval = 0.2f;

        void IInputListener.OnMouseEnter()
        {
            _isOver = true;
        }


        void IInputListener.OnMouseExit()
        {
            _isOver = _isPressed = false;
        }


        bool IInputListener.OnLeftMousePressed(Vector2 mousePos)
        {
            if (disabled)
                return false;

            _isPressed = true;
            SetCursorPosition(mousePos.X, mousePos.Y);
            selectionStart = cursor;
            hasSelection = true;
            var stage = GetStage();
            if (stage != null)
                stage.SetKeyboardFocus(this as IKeyboardListener);


            //flag clear selection
            if (Time.TotalTime - _lastClickPressedTime > _clickPressedCountInterval)
                _clickPressedCount = 0;

            _clickPressedCount++;




            //Console.WriteLine("{0}---{1} Left", Time.TotalTime - _lastClickPressedTime, _clickPressedCount);


            //Select word on double click and select all on tripe click
            var clickDownCount = _clickPressedCount;
            if (clickDownCount != 0)
            {
                if (clickDownCount % 2 == 0)
                    SelectWord();
                if ((clickDownCount % 3 == 0 && clickDownCount <= 3)
                    || (clickDownCount % 2 != 0 && clickDownCount > 3))
                    SelectAll();
            }
            _lastClickPressedTime = Time.TotalTime;

            return true;
        }

        bool IInputListener.OnRightMousePressed(Vector2 mousePos)
        {
            return false;
        }


        void IInputListener.OnMouseMoved(Vector2 mousePos)
        {
            if (DistanceOutsideBoundsToPoint(mousePos) > TextFieldBoundaryThreshold)
            {
                _isPressed = _isOver = false;
                GetStage().RemoveInputFocusListener(this);
            }
            else
            {
                SetCursorPosition(mousePos.X, mousePos.Y);
            }
        }

        void IInputListener.OnLeftMouseUp(Vector2 mousePos)
        {
            //flag clear selection
            if (selectionStart == cursor)
                hasSelection = false;

            //flag clear selection
            if (Time.TotalTime - _lastClickTime > _clickCountInterval)
                _clickCount = 0;

            _clickCount++;




            //Console.WriteLine("{0}---{1}",Time.TotalTime - _lastClickTime, _clickCount);
            _lastClickTime = Time.TotalTime;
            _isPressed = _isOver = false;
        }

        void IInputListener.OnRightMouseUp(Vector2 mousePos)
        {

        }

        bool IInputListener.OnMouseScrolled(int mouseWheelDelta)
        {
            return false;
        }

        #endregion

        public void SelectWord()
        {
            MoveCursor(false, true);
            var start = GetCursorPosition();
            MoveCursor(true, true);
            var end = GetCursorPosition();
            SetSelection(start, end);
        }

        #region IKeyboardListener

        void IKeyboardListener.KeyDown(Keys key)
        {
            if (disabled)
                return;

            lastBlink = 0;
            cursorOn = false;

            var isCtrlDown = InputUtils.IsControlDown();
            var jump = isCtrlDown && !passwordMode;
            var repeat = false;

            if (isCtrlDown)
            {

                if (key == Keys.KEY_V)              /** PATSE **/
                {
                    Paste(Raylib.GetClipboardText_(), true);
                }
                else if (key == Keys.KEY_C || key == Keys.KEY_INSERT)      /** COPY **/
                {
                    Copy();
                    return;

                }
                else if (key == Keys.KEY_X)     /** CUT **/
                {
                    Cut(true);
                    return;
                }
                else if (key == Keys.KEY_A)     /** SELECT ALL **/
                {
                    SelectAll();
                    return;
                }
                else if (cursor > 0)   /** Jump Delete **/
                {
                    if (key == Keys.KEY_BACKSPACE)
                    {
                        int tempCursor = cursor;
                        MoveCursor(false, true);
                        SetSelection(tempCursor, cursor);
                        cursor = Delete(true);
                        UpdateDisplayText();
                        return;
                    }
                    if (key == Keys.KEY_DELETE)
                    {
                        int tempCursor = cursor;
                        MoveCursor(true, true);
                        SetSelection(tempCursor, cursor);
                        cursor = Delete(true);
                        UpdateDisplayText();
                        return;
                    }
                }
            }

            if (InputUtils.IsShiftDown())
            {
                if (key == Keys.KEY_INSERT)
                    Paste(Raylib.GetClipboardText_(), true);
                else if (key == Keys.KEY_DELETE)
                    Cut(true);

                // jumping around shortcuts
                var temp = cursor;
                //Cursor moved
                var foundJumpKey = true;

                if (key == Keys.KEY_LEFT)
                {
                    MoveCursor(false, jump);
                    repeat = true;
                }
                else if (key == Keys.KEY_RIGHT)
                {
                    MoveCursor(true, jump);
                    repeat = true;
                }
                else if (key == Keys.KEY_HOME)
                {
                    GoHome();
                }
                else if (key == Keys.KEY_END)
                {
                    GoEnd();
                }
                else
                {
                    foundJumpKey = false;
                }

                if (foundJumpKey && !hasSelection)
                {
                    selectionStart = temp;
                    hasSelection = true;
                }
            }
            else
            {
                // Cursor movement or other keys (kills selection)
                if (key == Keys.KEY_LEFT)
                {
                    MoveCursor(false, jump);
                    ClearSelection();
                    repeat = true;
                }
                else if (key == Keys.KEY_RIGHT)
                {
                    MoveCursor(true, jump);
                    ClearSelection();
                    repeat = true;
                }
                else if (key == Keys.KEY_HOME)
                {
                    GoHome();
                }
                else if (key == Keys.KEY_END)
                {
                    GoEnd();
                }
            }
            cursor = (int)Mathf.Clamp(cursor, 0, text.Length);

            if (repeat)
            {
                var timerIsNull = _keyRepeatTimer == null;
                if (!timerIsNull) _keyRepeatTimer?.Stop();
                var duration = timerIsNull ? _keyRepeatStartTime : _keyRepeatTime;
                _keyRepeatTimer = Core.Schedule(duration, true, this, t => (t.Context as IKeyboardListener)?.KeyDown(key));
            }
        }

        void IKeyboardListener.KeyPressed(Keys key, char character)
        {

            if (InputUtils.IsControlDown())
                return;

            // disallow typing most ASCII control characters, which would show up as a space
            switch (key)
            {
                case Keys.KEY_BACKSPACE:
                case Keys.KEY_DELETE:
                case Keys.KEY_TAB:
                case Keys.KEY_ENTER:
                    break;
                default:
                    {
                        /** Handle non character ActionKey:**/
                        if ((int)character < 32 || (int)character > 126)
                            return;

                        break;
                    }
            }

            if (key == Keys.KEY_TAB && focusTraversal)
            {
                Next(InputUtils.IsShiftDown());
            }
            else
            {
                var hasChar = HasCharacter(style.Font, character);
                var enterPressed = key == Keys.KEY_ENTER;
                var backspacePressed = key == Keys.KEY_BACKSPACE;
                var deletePressed = key == Keys.KEY_DELETE;
                var tabPressed = key == Keys.KEY_TAB;
                //var add = enterPressed ? writeEnters : (!onlyFontChars);
                var add = enterPressed ? writeEnters : (!onlyFontChars || hasChar);
                var remove = backspacePressed || deletePressed;

                if (tabPressed)
                    OnTabPressed(this);

                if (enterPressed)
                    OnEnterPressed(this);

                if (add || remove)
                {
                    var oldText = text;
                    if (hasSelection)
                    {
                        cursor = Delete(false);
                    }
                    else
                    {
                        if (backspacePressed && cursor > 0)
                        {
                            text = text.Substring(0, cursor - 1) + text.Substring(cursor--);
                            renderOffset = 0;
                        }

                        if (deletePressed && cursor < text.Length)
                        {
                            text = text.Substring(0, cursor) + text.Substring(cursor + 1);
                        }
                    }

                    if (add && !remove)
                    {
                        // character may be added to the text.
                        if (!enterPressed && filter != null && !filter.AcceptChar(this, character))
                            return;

                        var isShiftDown = InputUtils.IsShiftDown() || InputUtils.Caplock;
                        if (!WithinMaxLength(text.Length))
                            return;

                        char insertChar = character;

                        insertChar = isShiftDown ?
                                RayUtils.CharToShiftedUSSymbol(insertChar) :
                                insertChar;

                        insertChar = isShiftDown ?
                                                char.ToUpper(insertChar) :
                                                char.ToLower(insertChar);
                        //Console.WriteLine(insertChar);

                        var insertion = enterPressed ? "\n" : insertChar.ToString();
                        text = Insert(cursor++, insertion, text);
                    }

                    ChangeText(oldText, text);
                    UpdateDisplayText();
                }
            }
        }


        void IKeyboardListener.KeyReleased(Keys key)
        {
            if (_keyRepeatTimer != null)
            {
                _keyRepeatTimer.Stop();
                _keyRepeatTimer = null;
            }
        }


        void IKeyboardListener.GainedFocus()
        {
            hasSelection = _isFocused = true;
        }


        void IKeyboardListener.LostFocus()
        {
            hasSelection = _isFocused = false;
            if (_keyRepeatTimer != null)
            {
                _keyRepeatTimer.Stop();
                _keyRepeatTimer = null;
            }
        }

        #endregion


        protected int LetterUnderCursor(float x)
        {
            var defaultChar = '\0';
#if true
            var bound = Raylib.GetGlyphAtlasRec(style.Font, defaultChar);
            var info = Raylib.GetGlyphInfo(style.Font, defaultChar);
            var halfSpaceSize = bound.width + info.advanceX;
            x -= textOffset + fontOffset + halfSpaceSize /*- style.font.getData().cursorX*/ -
                 glyphPositions[visibleTextStart];
            var n = glyphPositions.Count;
            for (var i = 0; i < n; i++)
            {
                if (glyphPositions[i] > x && i >= 1)
                {
                    if (glyphPositions[i] - x <= x - glyphPositions[i - 1])
                        return i;

                    return i - 1;
                }
            }
#endif

            return n - 1;
        }


        protected bool IsWordCharacter(char c)
        {
            return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
        }


        protected int[] WordUnderCursor(int at)
        {
            int start = at, right = text.Length, left = 0, index = start;
            for (; index < right; index++)
            {
                if (!IsWordCharacter(text[index]))
                {
                    right = index;
                    break;
                }
            }

            for (index = start - 1; index > -1; index--)
            {
                if (!IsWordCharacter(text[index]))
                {
                    left = index + 1;
                    break;
                }
            }

            return new int[] { left, right };
        }


        int[] WordUnderCursor(float x)
        {
            return WordUnderCursor(LetterUnderCursor(x));
        }


        bool WithinMaxLength(int size)
        {
            return maxLength <= 0 || size < maxLength;
        }


        public TextField SetMaxLength(int maxLength)
        {
            this.maxLength = maxLength;
            return this;
        }


        public int GetMaxLength()
        {
            return maxLength;
        }


        /// <summary>
        /// When false, text set by {@link #setText(String)} may contain characters not in the font, a space will be displayed instead.
        /// When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped
        /// when typed or pasted.
        /// </summary>
        /// <param name="onlyFontChars">If set to <c>true</c> only font chars.</param>
        public TextField SetOnlyFontChars(bool onlyFontChars)
        {
            this.onlyFontChars = onlyFontChars;
            return this;
        }


        public TextField SetStyle(TextFieldStyle style)
        {
            this.style = style;
            textHeight = style.FontScale;//style.Font.LineHeight;
            InvalidateHierarchy();
            return this;
        }


        /// <summary>
        /// Returns the text field's style. Modifying the returned style may not have an effect until {@link #setStyle(TextFieldStyle)} is called
        /// </summary>
        /// <returns>The style.</returns>
        public TextFieldStyle GetStyle()
        {
            return style;
        }


        protected void CalculateOffsets()
        {
            float visibleWidth = GetWidth();
            if (style.Background != null)
                visibleWidth -= style.Background.LeftWidth + style.Background.RightWidth;

            var glyphCount = glyphPositions.Count;

            // Check if the cursor has gone out the left or right side of the visible area and adjust renderoffset.
            var distance = glyphPositions[Math.Max(0, cursor - 1)] + renderOffset;
            if (distance <= 0)
            {
                renderOffset -= distance;
            }
            else
            {
                var index = Math.Min(glyphCount - 1, cursor + 1);
                var minX = glyphPositions[index] - visibleWidth;
                if (-renderOffset < minX)
                {
                    renderOffset = -minX;
                }
            }

            // calculate first visible char based on render offset
            visibleTextStart = 0;
            var startX = 0f;
            for (var i = 0; i < glyphCount; i++)
            {
                if (glyphPositions[i] >= -renderOffset)
                {
                    visibleTextStart = Math.Max(0, i);
                    startX = glyphPositions[i];
                    break;
                }
            }

            // calculate last visible char based on visible width and render offset
            var length = displayText.Length;
            visibleTextEnd = Math.Min(length, cursor + 1);
            for (; visibleTextEnd <= length; visibleTextEnd++)
                if (glyphPositions[visibleTextEnd] > startX + visibleWidth)
                    break;

            visibleTextEnd = Math.Max(0, visibleTextEnd - 1);

            if ((textHAlign & AlignInternal.Left) == 0)
            {
                textOffset = visibleWidth - (glyphPositions[visibleTextEnd] - startX);
                if ((textHAlign & AlignInternal.Center) != 0)
                    textOffset = MathF.Round(textOffset * 0.5f);
            }
            else
            {
                textOffset = startX + renderOffset;
            }

            // calculate selection x position and width
            if (hasSelection)
            {
                var minIndex = Math.Min(cursor, selectionStart);
                var maxIndex = Math.Max(cursor, selectionStart);
                var minX = Math.Max(glyphPositions[minIndex], -renderOffset);
                var maxX = Math.Min(glyphPositions[maxIndex], visibleWidth - renderOffset);
                selectionX = minX;

                if (renderOffset == 0)
                    selectionX += textOffset;

                selectionWidth = maxX - minX;
            }
        }


        #region Drawing

        public override void Draw(float parentAlpha)
        {
            var font = style.Font;
            var fontSize = style.FontScale;
            var fontSpacing = style.FontSpacing;
            var fontColor = (disabled && style.DisabledFontColor.HasValue)
                ? style.DisabledFontColor.Value
                : ((_isFocused && style.FocusedFontColor.HasValue) ? style.FocusedFontColor.Value : style.FontColor);
            IDrawable selection = style.Selection;
            IDrawable background = (disabled && style.DisabledBackground != null)
                ? style.DisabledBackground
                : ((_isFocused && style.FocusedBackground != null) ? style.FocusedBackground : style.Background);

            var color = GetColor();
            var x = GetX();
            var y = GetY();
            var width = GetWidth();
            var height = GetHeight();

            float bgLeftWidth = 0, bgRightWidth = 0;
            if (background != null)
            {
                background.Draw(x, y, width, height, ColorExt.Create(color, (int)(color.a * parentAlpha)));
                bgLeftWidth = background.LeftWidth;
                bgRightWidth = background.RightWidth;
            }

            var textY = GetTextY(font, background);
            //var yOffset = (textY < 0) ? -textY - font.LineHeight / 2f + GetHeight() / 2 : 0;
            var yOffset = (textY < 0) ? -textY - fontSize / 2f + GetHeight() / 2 : 0;
            CalculateOffsets();


            if (!style.SelectionOnTop)
            {
                Raylib.BeginBlendMode(style.SelectionBlendMode);
                if (_isFocused && hasSelection && selection != null)
                    DrawSelection(selection, font, x + bgLeftWidth, y + textY + yOffset);
                Raylib.EndBlendMode();
            }

            if (displayText.Length == 0)
            {
                if (!_isFocused && messageText != null)
                {

                    var messageFontColor = style.MessageFontColor.HasValue
                        ? style.MessageFontColor.Value
                        : new Color(180, 180, 180, (int)(color.a * parentAlpha));
                    var messageFont = style.MessageFont != null ? style.MessageFont : font;
                    var pos = new Vector2(x + bgLeftWidth, y + textY + yOffset);

                    Raylib.DrawTextPro(messageFont.Value, messageText, pos, Vector2.Zero, rotation, fontSize, fontSpacing, messageFontColor);

                    //batcher.DrawString(messageFont, messageText,pos
                    //	, messageFontColor);

                    //messageFont.draw( batcher.batcher, messageText, x + bgLeftWidth, y + textY + yOffset, 0, messageText.length(),
                    //	width - bgLeftWidth - bgRightWidth, textHAlign, false, "..." );
                }
            }
            else
            {
                var col = ColorExt.Create(fontColor, (int)(fontColor.a * parentAlpha));
                var t = displayText.Substring(visibleTextStart, visibleTextEnd - visibleTextStart);
                var pos = new Vector2(x + bgLeftWidth + textOffset, y + textY + yOffset);

                Raylib.BeginBlendMode(style.TextBlendMode);
                Raylib.DrawTextPro(font, t, pos, Vector2.Zero, rotation, fontSize, fontSpacing, col);
                Raylib.EndBlendMode();


                //batcher.DrawString(font, t, new Vector2(x + bgLeftWidth + textOffset, y + textY + yOffset),
                //col);
            }

            if (style.SelectionOnTop)
            {
                Raylib.BeginBlendMode(style.SelectionBlendMode);
                if (_isFocused && hasSelection && selection != null)
                    DrawSelection(selection, font, x + bgLeftWidth, y + textY + yOffset);
                Raylib.EndBlendMode();
            }




            if (_isFocused && !disabled)
            {
                Blink();
                if (cursorOn && style.Cursor != null)
                    DrawCursor(style.Cursor, font, x + bgLeftWidth, y + textY + yOffset);
            }
        }


        protected float GetTextY(BitmapFont font, IDrawable background)
        {
            float height = GetHeight();
            float textY = textHeight / 2 + style.Padding.Bottom;
            if (background != null)
            {
                var bottom = background.BottomHeight;
                textY = textY - (height - background.TopHeight - bottom) / 2 + bottom;
            }
            else
            {
                textY = textY - height / 2;
            }

            return textY;
        }


        /// <summary>
        /// Draws selection rectangle
        /// </summary>
        /// <param name="selection">Selection.</param>
        /// <param name="batch">Batch.</param>
        /// <param name="font">Font.</param>
        /// <param name="x">The x coordinate.</param>
        /// <param name="y">The y coordinate.</param>
        protected void DrawSelection(IDrawable selection, BitmapFont font, float x, float y)
        {
            selection.Draw(x + selectionX + renderOffset + fontOffset, y - style.Padding.Bottom / 2,
                selectionWidth, textHeight, Color.WHITE);
        }

        protected void DrawCursor(IDrawable cursorPatch, BitmapFont font, float x, float y)
        {
            cursorPatch.Draw(
                (x + textOffset + glyphPositions[cursor] - glyphPositions[visibleTextStart] + fontOffset - 1) /*font.getData().cursorX*/,
                y - style.Padding.Bottom / 2, cursorPatch.MinWidth, textHeight, color);
        }

        #endregion

        private static bool HasCharacter(Font font, char character)
        {
            int codePoint = Raylib.GetGlyphIndex(Raylib.GetFontDefault(), 62);
            return codePoint != '?';
        }

        void UpdateDisplayText()
        {
            var textLength = text.Length;

            _textBuffer.Clear();
            for (var i = 0; i < textLength; i++)
            {
                var c = text[i];
                _textBuffer.Append(HasCharacter(style.Font, c) ? c : ' ');
            }

            var newDisplayText = _textBuffer.ToString();

            if (passwordMode && HasCharacter(style.Font, passwordCharacter))
            {
                if (passwordBuffer == null)
                    passwordBuffer = new StringBuilder(newDisplayText.Length);
                else if (passwordBuffer.Length > textLength)
                    passwordBuffer.Clear();

                for (var i = passwordBuffer.Length; i < textLength; i++)
                    passwordBuffer.Append(passwordCharacter);
                displayText = passwordBuffer.ToString();
            }
            else
            {
                displayText = newDisplayText;
            }

            //layout.setText( font, displayText );
            glyphPositions.Clear();
            float x = 0;
            if (displayText.Length > 0)
            {
                for (var i = 0; i < displayText.Length; i++)
                {
                    var w = Raylib.GetGlyphAtlasRec(style.Font, displayText[i]).width + style.FontSpacing;
                    //var region = Raylib.GetGlyphInfo(style.Font, displayText[i]);//style.Font[displayText[i]];
                    // we dont have fontOffset in BitmapFont, it is the first Glyph in a GlyphRun
                    //if( i == 0 )
                    //	fontOffset = region.xAdvance;

                    glyphPositions.Add(x);
                    x += w;
                }

                //GlyphRun run = layout.runs.first();
                //FloatArray xAdvances = run.xAdvances;
                //fontOffset = xAdvances.first();
                //for( int i = 1, n = xAdvances.size; i < n; i++ )
                //{
                //	glyphPositions.add( x );
                //	x += xAdvances.get( i );
                //}
            }
            else
            {
                fontOffset = 0;
            }

            glyphPositions.Add(x);

            if (selectionStart > newDisplayText.Length)
                selectionStart = textLength;
        }


        void Blink()
        {
            if ((Time.TotalTime - lastBlink) > blinkTime)
            {
                cursorOn = !cursorOn;
                lastBlink = Time.TotalTime;
            }
        }


        #region Text manipulation

        /// <summary>
        /// Copies the contents of this TextField to the {@link Clipboard} implementation set on this TextField
        /// </summary>
        public void Copy()
        {
            if (hasSelection && !passwordMode)
            {
                var start = Math.Min(cursor, selectionStart);
                var length = Math.Max(cursor, selectionStart) - start;
                var subText = text.Substring(start, length);
                Raylib.SetClipboardText(subText);
            }
        }


        /// <summary>
        /// Copies the selected contents of this TextField to the {@link Clipboard} implementation set on this TextField, then removes it
        /// </summary>
        public void Cut()
        {
            Cut(programmaticChangeEvents);
        }


        void Cut(bool fireChangeEvent)
        {
            if (hasSelection && !passwordMode)
            {
                Copy();
                cursor = Delete(fireChangeEvent);
                UpdateDisplayText();
            }
        }


        void Paste(string content, bool fireChangeEvent)
        {
            if (content == null)
                return;

            _textBuffer.Clear();
            int textLength = text.Length;
            if (hasSelection)
                textLength -= Math.Abs(cursor - selectionStart);

            //var data = style.font.getData();
            for (int i = 0, n = content.Length; i < n; i++)
            {
                if (!WithinMaxLength(textLength + _textBuffer.Length))
                    break;

                var c = content[i];
                if (!(writeEnters && c == '\r'))
                {
                    if (onlyFontChars && !HasCharacter(style.Font, c))
                        continue;

                    if (filter != null && !filter.AcceptChar(this, c))
                        continue;
                }

                _textBuffer.Append(c);
            }

            content = _textBuffer.ToString();

            if (hasSelection)
                cursor = Delete(fireChangeEvent);
            if (fireChangeEvent)
                ChangeText(text, Insert(cursor, content, text));
            else
                text = Insert(cursor, content, text);
            UpdateDisplayText();
            cursor += content.Length;
        }


        string Insert(int position, string text, string to)
        {
            if (to.Length == 0)
                return text;

            return to.Substring(0, position) + text + to.Substring(position, to.Length - position);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="fireChangeEvent">flag changing text</param>
        /// <returns>index of cursor</returns>
        int Delete(bool fireChangeEvent)
        {
            var from = selectionStart;
            var to = cursor;
            var minIndex = Math.Min(from, to);
            var maxIndex = Math.Max(from, to);
            var newText = (minIndex > 0 ? text.Substring(0, minIndex) : "")
                          + (maxIndex < text.Length ? text.Substring(maxIndex, text.Length - maxIndex) : "");

            if (fireChangeEvent)
                ChangeText(text, newText);
            else
                text = newText;

            ClearSelection();
            return minIndex;
        }


        /// <summary>
        /// Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage
        /// up: If true, the TextField with the same or next smallest y coordinate is found, else the next highest.
        /// </summary>
        /// <param name="up">Up.</param>
        public void Next(bool up)
        {
            var stage = GetStage();
            if (stage == null)
                return;

            var tmp2 = Vector2.Zero;
            var tmp1 = GetParent().LocalToStageCoordinates(new Vector2(GetX(), GetY()));
            var textField = FindNextTextField(stage.GetElements(), null, tmp2, tmp1, up);
            if (textField == null)
            {
                // Try to wrap around.
                if (up)
                    tmp1 = new Vector2(float.MinValue, float.MinValue);
                else
                    tmp1 = new Vector2(float.MaxValue, float.MaxValue);
                textField = FindNextTextField(GetStage().GetElements(), null, tmp2, tmp1, up);
            }

            if (textField != null)
                stage.SetKeyboardFocus(textField);
            SelectAll();
        }


        TextField FindNextTextField(List<Element> elements, TextField best, Vector2 bestCoords, Vector2 currentCoords,
                                    bool up)
        {
            bestCoords = Vector2.Zero;
            for (int i = 0, n = elements.Count; i < n; i++)
            {
                var element = elements[i];
                if (element == this)
                    continue;

                if (element is TextField)
                {
                    var textField = (TextField)element;
                    if (textField.IsDisabled() || !textField.focusTraversal)
                        continue;

                    var elementCoords = element.GetParent()
                        .LocalToStageCoordinates(new Vector2(element.GetX(), element.GetY()));
                    if ((elementCoords.Y < currentCoords.Y ||
                         (elementCoords.Y == currentCoords.Y && elementCoords.X > currentCoords.X)) ^ up)
                    {
                        if (best == null
                            || (elementCoords.Y > bestCoords.Y ||
                                (elementCoords.Y == bestCoords.Y && elementCoords.X < bestCoords.X)) ^ up)
                        {
                            best = (TextField)element;
                            bestCoords = elementCoords;
                        }
                    }
                }
                else if (element is Group)
                {
                    best = FindNextTextField(((Group)element).GetChildren(), best, bestCoords, currentCoords, up);
                }
            }

            return best;
        }

        #endregion


        /// <summary>
        /// if str is null, "" is used
        /// </summary>
        /// <param name="str">String.</param>
        public void AppendText(string str)
        {
            if (ShouldIgnoreTextUpdatesWhileFocused && _isFocused)
                return;

            if (str == null)
                str = "";

            ClearSelection();
            cursor = text.Length;
            Paste(str, programmaticChangeEvents);
        }


        /// <summary>
        /// str If null, "" is used
        /// </summary>
        /// <param name="str">String.</param>
        public TextField SetText(string str)
        {
            if (ShouldIgnoreTextUpdatesWhileFocused && _isFocused)
                return this;

            if (str == null)
                str = "";
            if (str == text)
                return this;

            ClearSelection();
            var oldText = text;
            text = "";
            Paste(str, false);
            if (programmaticChangeEvents)
                ChangeText(oldText, text);
            cursor = 0;

            return this;
        }


        /// <summary>
        /// force sets the text without validating or firing change events. Use at your own risk.
        /// </summary>
        /// <param name="str">String.</param>
        public TextField SetTextForced(string str)
        {
            text = str;
            UpdateDisplayText();

            // ensure our cursor is in bounds
            cursor = text.Length;

            return this;
        }


        /// <summary>
        /// Never null, might be an empty string
        /// </summary>
        /// <returns>The text.</returns>
        public string GetText()
        {
            return text;
        }


        /// <summary>
        /// oldText May be null
        /// </summary>
        /// <param name="oldText">Old text.</param>
        /// <param name="newText">New text.</param>
        void ChangeText(string oldText, string newText)
        {
            if (newText == oldText)
                return;

            text = newText;

            if (OnTextChanged != null)
                OnTextChanged(this, text);
        }


        /// <summary>
        /// If false, methods that change the text will not fire {@link onTextChanged}, the event will be fired only when user changes the text
        /// </summary>
        /// <param name="programmaticChangeEvents">If set to <c>true</c> programmatic change events.</param>
        public TextField SetProgrammaticChangeEvents(bool programmaticChangeEvents)
        {
            this.programmaticChangeEvents = programmaticChangeEvents;
            return this;
        }


        public int GetSelectionStart()
        {
            return selectionStart;
        }


        public string GetSelection()
        {
            return hasSelection
                ? text.Substring(Math.Min(selectionStart, cursor), Math.Max(selectionStart, cursor))
                : "";
        }


        /// <summary>
        /// Sets the selected text
        /// </summary>
        /// <param name="selectionStart">Selection start.</param>
        /// <param name="selectionEnd">Selection end.</param>
        public TextField SetSelection(int selectionStart, int selectionEnd)
        {
            Insist.IsFalse(selectionStart < 0, "SelectionStart must be >= 0");
            Insist.IsFalse(selectionEnd < 0, "SelectionEnd must be >= 0");

            selectionStart = Math.Min(text.Length, selectionStart);
            selectionEnd = Math.Min(text.Length, selectionEnd);

            if (selectionEnd == selectionStart)
            {
                ClearSelection();
                return this;
            }

            if (selectionEnd < selectionStart)
            {
                int temp = selectionEnd;
                selectionEnd = selectionStart;
                selectionStart = temp;
            }

            hasSelection = true;
            this.selectionStart = selectionStart;
            cursor = selectionEnd;

            return this;
        }


        public void SelectAll()
        {
            SetSelection(0, text.Length);
        }


        public void ClearSelection()
        {
            hasSelection = false;
        }


        protected void SetCursorPosition(float x, float y)
        {
            lastBlink = 0;
            cursorOn = false;
            cursor = LetterUnderCursor(x);
        }


        /// <summary>
        /// Sets the cursor position and clears any selection
        /// </summary>
        /// <param name="cursorPosition">Cursor position.</param>
        public TextField SetCursorPosition(int cursorPosition)
        {
            Insist.IsFalse(cursorPosition < 0, "cursorPosition must be >= 0");
            ClearSelection();
            cursor = Math.Min(cursorPosition, text.Length);
            return this;
        }


        public int GetCursorPosition()
        {
            return cursor;
        }


        protected void GoHome()
        {
            cursor = 0;
        }


        protected void GoEnd()
        {
            cursor = text.Length;
        }

        /// <summary>
        /// programable Move cursor 
        /// </summary>
        /// <param name="forward">true to right, false to left</param>
        /// <param name="jump">jump entire word</param>
        protected void MoveCursor(bool forward, bool jump)
        {
            var limit = forward ? text.Length : 0;
            var charOffset = forward ? 0 : -1;

            if ((forward && cursor == limit) || (!forward && cursor == 0))
                return;


            while ((forward ? ++cursor < limit : --cursor > limit) && jump)
            {
                if (!ContinueCursor(cursor, charOffset))
                    break;
            }
        }


        protected bool ContinueCursor(int index, int offset)
        {
            var c = text[index + offset];
            return IsWordCharacter(c);
        }


        #region Configuration

        public TextField SetPreferredWidth(float preferredWidth)
        {
            _preferredWidth = preferredWidth;
            return this;
        }


        /// <summary>
        /// filter May be null
        /// </summary>
        /// <param name="filter">Filter.</param>
        public TextField SetTextFieldFilter(ITextFieldFilter filter)
        {
            this.filter = filter;
            return this;
        }


        public ITextFieldFilter GetTextFieldFilter()
        {
            return filter;
        }


        /// <summary>
        /// If true (the default), tab/shift+tab will move to the next text field
        /// </summary>
        /// <param name="focusTraversal">If set to <c>true</c> focus traversal.</param>
        public TextField SetFocusTraversal(bool focusTraversal)
        {
            this.focusTraversal = focusTraversal;
            return this;
        }


        /// <summary>
        /// May be null
        /// </summary>
        /// <returns>The message text.</returns>
        public string GetMessageText()
        {
            return messageText;
        }


        /// <summary>
        /// Sets the text that will be drawn in the text field if no text has been entered.
        /// </summary>
        /// <param name="messageText">Message text.</param>
        public TextField SetMessageText(string messageText)
        {
            this.messageText = messageText;
            return this;
        }


        /// <summary>
        /// Sets text horizontal alignment (left, center or right).
        /// </summary>
        /// <param name="alignment">Alignment.</param>
        public TextField SetAlignment(Align alignment)
        {
            textHAlign = (int)alignment;
            return this;
        }


        /// <summary>
        /// If true, the text in this text field will be shown as bullet characters.
        /// </summary>
        /// <param name="passwordMode">Password mode.</param>
        public TextField SetPasswordMode(bool passwordMode)
        {
            this.passwordMode = passwordMode;
            UpdateDisplayText();
            return this;
        }


        public bool IsPasswordMode()
        {
            return passwordMode;
        }


        /// <summary>
        /// Sets the password character for the text field. The character must be present in the {@link BitmapFont}. Default is 149 (bullet)
        /// </summary>
        /// <param name="passwordCharacter">Password character.</param>
        public TextField SetPasswordCharacter(char passwordCharacter)
        {
            this.passwordCharacter = passwordCharacter;
            if (passwordMode)
                UpdateDisplayText();
            return this;
        }


        public TextField SetBlinkTime(float blinkTime)
        {
            this.blinkTime = blinkTime;
            return this;
        }


        public TextField SetDisabled(bool disabled)
        {
            this.disabled = disabled;
            return this;
        }


        public bool IsDisabled()
        {
            return disabled;
        }

        #endregion


        /// <summary>
        /// Interface for filtering characters entered into the text field.
        /// </summary>
        public interface ITextFieldFilter
        {
            bool AcceptChar(TextField textField, char c);
        }
    }


    public class TextFieldStyle
    {
        public BitmapFont Font;
        public Padding Padding;
        public float FontScale = 10f;
        public Color FontColor = Color.WHITE;
        internal float FontSpacing = 2f;

        /** Optional. */
        public Color? FocusedFontColor, DisabledFontColor;

        /** Optional. */
        public IDrawable Background, FocusedBackground, DisabledBackground, Cursor, Selection;

        /** Optional. */
        public BitmapFont? MessageFont;

        /** Optional. */
        public Color? MessageFontColor;

        public BlendMode SelectionBlendMode, TextBlendMode;
        public bool SelectionOnTop;

        public TextFieldStyle()
        {
            Font = Raylib.GetFontDefault();
            MessageFont = Raylib.GetFontDefault();
            MessageFontColor = Color.GRAY;
            SelectionBlendMode = BlendMode.BLEND_ALPHA;
            TextBlendMode = BlendMode.BLEND_ALPHA;
            SelectionOnTop = false;

        }


        public TextFieldStyle(BitmapFont? font, Color fontColor, IDrawable cursor, IDrawable selection,
                              IDrawable background)
        {
            Background = background;
            Cursor = cursor;
            Font = font ?? Raylib.GetFontDefault();
            FontColor = fontColor;
            Selection = selection;
        }


        public static TextFieldStyle Create(Color fontColor, Color cursorColor, Color selectionColor,
                                            Color backgroundColor)
        {
            var cursor = new PrimitiveDrawable(cursorColor);
            cursor.MinWidth = 1;
            cursor.LeftWidth = 4;

            var background = new PrimitiveDrawable(backgroundColor);
            background.LeftWidth = background.RightWidth = 10f;
            background.BottomHeight = background.TopHeight = 5f;

            return new TextFieldStyle
            {
                FontColor = fontColor,
                Cursor = cursor,
                Selection = new PrimitiveDrawable(selectionColor),
                Background = background
            };
        }


        public static TextFieldStyle CreateRaylib()
        {
            var cursor = new PrimitiveDrawable(1, 20, Color.WHITE);
            cursor.LeftWidth = 10f;

            /* normal Background */
            var background = new PrimitiveDrawable(null, UIDefault.OutlineUp);
            background.LeftWidth = background.RightWidth = 10f;
            background.BottomHeight = background.TopHeight = 5f;

            /* focused Background */
            var focusedBackground = new PrimitiveDrawable(null, UIDefault.OutlineDown);
            focusedBackground.LeftWidth = focusedBackground.RightWidth = 10f;
            focusedBackground.BottomHeight = focusedBackground.TopHeight = 5f;

            return new TextFieldStyle
            {
                Background = background,
                FocusedBackground = focusedBackground,

                Cursor = new PrimitiveDrawable(1, 20, Color.WHITE),
                Selection = new PrimitiveDrawable(10, 30, Raylib.ColorAlpha(Color.SKYBLUE, .3f), Color.BLANK),
                FontColor = Color.GRAY,
                FocusedFontColor = Color.WHITE,

                SelectionOnTop = true,
                SelectionBlendMode = BlendMode.BLEND_SUBTRACT_COLORS,
                TextBlendMode = BlendMode.BLEND_ALPHA,
            };
        }

        public TextFieldStyle Clone()
        {
            return new TextFieldStyle
            {
                Font = Font,
                FontColor = FontColor,
                FocusedFontColor = FocusedFontColor,
                DisabledFontColor = DisabledFontColor,
                Background = Background,
                FocusedBackground = FocusedBackground,
                DisabledBackground = DisabledBackground,
                Cursor = Cursor,
                Selection = Selection,
                MessageFont = MessageFont,
                MessageFontColor = MessageFontColor
            };
        }
    }


    public class DigitsOnlyFilter : TextField.ITextFieldFilter
    {
        public bool AcceptChar(TextField textField, char c)
        {
            return Char.IsDigit(c) || c == '-';
        }
    }


    public class FloatFilter : TextField.ITextFieldFilter
    {
        public bool AcceptChar(TextField textField, char c)
        {
            // only allow one .
            if (c == '.')
                return !textField.GetText().Contains(".");

            return Char.IsDigit(c) || c == '-';
        }
    }


    public class BoolFilter : TextField.ITextFieldFilter
    {
        public bool AcceptChar(TextField textField, char c)
        {
            if (c == 't' || c == 'T')
                textField.SetTextForced("true");

            if (c == 'f' || c == 'F')
                textField.SetTextForced("false");

            return false;
        }
    }
}
#endif  
